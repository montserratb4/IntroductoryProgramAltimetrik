---
title: "[]{#_urcwq4z7wc3h .anchor}**Become a Front End Developer** "
---

**with Altimetrik \| 2nd Edition**

**Documentation**

\[Montserrat BriceÃ±o\]

# Index

**2**

**Agile methodology**

Agile methodology, centered on software development, focuses on the idea
of repetitive development involving the constant collaboration of all
interested parts of the project at all stages. It helps the team to
deliver the product with a better quality in less time than expected.
![](vertopal_02f27a16d689469f891c7e1f4ebd6d47/media/image1.jpg){width="3.7031255468066493in"
height="2.505323709536308in"}

Agile methodologies promote disciplined project management, encouraging
self-organization and teamwork, as well as frequent inspection and
adaptation of the field we're working on. It's intended for a fast and
high-quality delivery of the projects to make.

This method begins with a description of the product from the client
towards the work team, how it is supposed to function and what for. This
step helps the team to certainly know the expectations of the client.
Once the project starts, the work team plans the path to follow, the
execution and evaluation of said project, which might change in the
future to guarantee a better adaptation for the client\'s wants and
needs.![](vertopal_02f27a16d689469f891c7e1f4ebd6d47/media/image6.png){width="3.7021259842519685in"
height="2.932292213473316in"}

As said, all parts are involved in this, so it is fundamental for
everyone to keep in touch with the process to achieve a better final
product.

## **Scrum** 

Scrum is a subset of agile. In fact, it's the most used subset of agile
methodologies. It is most often used to manage complex software
development using iterative incremental practices. This method increases
productivity and reduces time compared to the waterfall processes. Scrum
enables rapid and smooth adjustments to the changes that the project may
present over time and allows more control over the project status by
needing the team to have regular meetings to discuss where the project
is heading.

These meetings include daily short meetings to dissipate doubts and an
extended weekly meeting to discuss more deeply how the project is going.

Scrum requires a Scrum master to provide an environment where:

1.  A product owner orders the work for a complex problem into a product
    > backlog.

2.  The scrum team turns a selection of the work into an Increment of
    > value during a Sprint.
    > ![](vertopal_02f27a16d689469f891c7e1f4ebd6d47/media/image12.jpg){width="4.151042213473316in"
    > height="3.6746926946631673in"}

3.  The scrum team and its stakeholders inspect the results and adjust
    > for the next sprint.

4.  Repeat!

A sprint is a short period of time in which a scrum team works to
complete a set amount of work. Sprints are placed in the heart of scrum
and agile methodologies and they're the base to an efficient and
lightweight work.

## **Kanban**

Kanban is also a subset of agile. It's a framework that organizes tasks
by cards added to different columns on a board.

Columns are divided into: backlog, to do, doing, blocked and done. Each
card must be moved to its corresponding column until
*done*.![](vertopal_02f27a16d689469f891c7e1f4ebd6d47/media/image9.png){width="3.4218755468066493in"
height="2.1002854330708662in"}

![](vertopal_02f27a16d689469f891c7e1f4ebd6d47/media/image8.png){width="6.5in"
height="2.5797036307961503in"}

![](vertopal_02f27a16d689469f891c7e1f4ebd6d47/media/image11.png){width="3.369792213473316in"
height="3.088975284339458in"}

## **Extreme Programming (XP)**

It belongs to the subsets of agile methodologies as well. Instead of
delivering everything you could possibly want on some date far in the
future, this process delivers the software you need as you need it. This
process encourages developers to respond to customer changes even late
in the cycle of said project.

XP emphasizes teamwork and self-organization as any agile methodology;
managers, customers and developers are all equal partners in a
collaborative team. Implements a simple (yet effective) environment
enabling teams to become highly productive. Extreme Programming develops
a software project in five essential ways: constant and efficient
[communication]{.ul} between all parts involved, a [simple]{.ul} and
clean model of the project, [feedback]{.ul} from testing the project
with the customer, [respect]{.ul} between the team members and their
work, and [courage]{.ul} to respond to future changes and criticism.

## **Git**

Git is a version control system designed for efficiency, confidentiality
and compatibility between all the versions of the project to modify.

What makes it different from other models is its branching
functionality. Git encourages developers to have multiple branches that
can be entirely independent from each other. The creation, merging
(combination) and deletion of said branches takes seconds.

This means you can switch between branches without editing the main one,
have several branches for specific functions, and even create a branch
to experiment with without altering the main branch. Think about it as a
tree! You can cut off one branch, take off some leaves, even paint a
branch if you like, but the trunk itself is never affected. To do this,
we use commands!

### 10 most used commands: 

-   *Git clone:* this command makes an identical copy of the latest
    > version of a project in a repository (an online information
    > deposit) and saves it into your computer. A really easy way to do
    > this is by coding: *git clone
    > \<[[https://name-of-the-repository-link]{.ul}](https://name-of-the-repository-link)\>*

-   *Git branch:* we can use the branch command for, creating, editing
    > and deleting branches.

> To create a new one: *git branch \<branch name\>*. This will create it
> into the local repository.
>
> To push this new branch into the remote repository: *git push -u
> \<remote\> \<branch-name\>*
>
> To view the existent branches: *git branch* or *git branch \--list*
>
> To delete a branch: *git branch -d \<branch-name\>*

-   *Git checkout:* to work on a branch, first we need to switch to it.
    > We use this command to switch from one branch to another. We can
    > also use it for checking out files and commits: *git checkout
    > \<name-of-your-branch\>.*

> To successfully switch between branches you need to follow these
> steps:

-   The changes in your current branch must be committed or stashed
    > before you switch.

-   The branch you want to check out should exist in your local

Of course, there's a shortcut command that allows you to do combine
these and save time: *git checkout -b \<name-of-your-branch\>*

-   *Git status:* this command gives us all the necessary information of
    > the current branch. Like whether the current branch is up to date;
    > whether there is anything to commit, push or even pull; whether
    > there are file to stage, file unstaged or untracked; whether there
    > are files created, modified or deleted. To use it we code: *git
    > status*.

-   *Git add:* when we create, modify or delete a file, these changes
    > will happen in our local and won't be included in the next commit
    > unless we change the configurations. In order to do this, we need
    > to use the git add command to include the changes of a file into
    > our next commit. To add a single file: *git add \<file\>.* And to
    > add everything at once: *git add -A.* We need to make clear that
    > this command DOES NOT change the repository and changes are NOT
    > saved until we use git commit.

-   *Git commit:* used for saving our changes, it's like a checkpoint in
    > a videogame where we can go back later if needed. We need to write
    > a little message to explain what we have developed or changed in
    > the code: *git commit -m "commit message".* This command saves
    > your changes only locally.

-   *Git push:* this one submits your commits to the remote repository:
    > *git push \<remote\> \<branch-name\>*

-   Nonetheless, if your branch is fresh out of the oven, you also need
    > to upload the branch with this command right here: *git push -
    > -set-upstream \<remote\> \<name-of-your-branch\>* or *git push -u
    > origin \<branch_name\>.* This command only uploads changes that
    > are commited.

-   *Git pull:* this command is used to get updates from the remote
    > repository. It gets the updates from the repository and
    > immediately applies the latest changes into your local: *git pull
    > \<remote\>.*

-   *Git revert:* this one is used to undo our changes locally or
    > remotely, [carefully.]{.ul} To see our commit history, we need to
    > use *git log--online.* Then we just need to specify the code next
    > to our wanted commit: *git revert \<commit number\>.* This action
    > will deploy a window like this one but we just have to press
    > *shift + q* to
    > exit.![](vertopal_02f27a16d689469f891c7e1f4ebd6d47/media/image7.png){width="3.4583333333333335in"
    > height="2.1041666666666665in"}

> The git command will undo the given commit, but will create a new
> commit without deleting the older one. The advantage of using this
> little command is that it doesn't touch the commit history, with which
> you can still see all of the previous information in your history,
> even the reverted ones.
>
> Another advantage is that everything happens in our local system
> unless we push it into the remote repository. This is why git revert
> is safer to use.

-   *Git merge:* this command is the final step, for when you've
    > completed development in your branch and you are sure that
    > everything works just fine. We are going to merge the branch
    > (including all of its commits) with the dev branch using: *git
    > merge.* It's important to keep in mind that you first need to be
    > on the specific branch you want to merge with your feature branch.

> First, we need to switch to the dev branch by using: *git checkout
> dev*. Before merging, we have to update our local dev branch by
> coding: *git fetch*. Finally, we can merge the feature branch into the
> dev branch by using: *git merge \<branch-name\>.* Make sure our dev
> branch has the latest version before we merge our branches, or we may
> have some conflicts to resolve.

###  **Tags and commits:**

A tag is a feature of git. A specific point in the repository can be
identified by defining the tag for that point. It is used to move
between versions of the repository without altering them. The tag can be
created for a specific commit of the git history. It\'s better to know
how to create the tag for the repository before adding a tag to a
specific commit.

To create a new tag, we need to execute: *git tag \<tagname\>.* We
substitute *tagname* with a specific semantic name. A common pattern to
use are numbers of the version, like *1.04.2.*

###  **Stash**

This command (*git stash)* stores temporally the changes that have been
made in the code we\'re working on so we can work on another code and,
later on, we can come back and apply the wanted changes. It is practical
if you need to deal with other things constantly and rapidly but you
don\'t have the changes in the code finished to confirm and submit. Keep
in mind that the stash is only local and changes effectuated don\'t
transfer to the server when uploaded to the repo.

At this point, we have the liberty to go to another branch and put in
practice all we\'ve learned before with git, then once we\'re ready,
come back and apply the stash.

We can also apply a stash change using the command *git stash pop*. Once
we *pop* the stash, changes in it will be deleted and applied again to
the code we\'re working on.

Another option is to apply again the changes in the code we\'re working
on and keep them in our stash using the command *git stash apply.* This
is really useful if you want to apply the same changes of a stash in
several branches.

Also, we can use *git stash* multiple times to create several *stashes*,
and then use *git stash list* to visualize them. We can identify slashes
by the word \"WIP\" which stands for \"work in progress\" in the upper
part of the branch.

###  **Hooks**

This is the way git has to fire off custom scripts when certain
important actions occur. They can be divided in two groups: server-side
and client-side. Client-side Hooks are triggered by operations such as
committing and merging. While server-side hooks run on network operation
such as receiving pushed commits. The most used commands are
*pre-commit* and *pre-push.*

###  **Branching strategies and GitFlow**

A branching strategy is a set of rules that a work team develops when
writing, merging and deploying code when using a VCS. These rules enable
the team the possibility of stipulating how they interact with a shared
codebase.

Such strategy is necessary as it helps to keep the repository organized
to avoid errors in its application.
![](vertopal_02f27a16d689469f891c7e1f4ebd6d47/media/image2.png){width="3.1458333333333335in"
height="1.7395833333333333in"}

GitFlow is a branching strategy. This one enables parallel development
in a branch separated from the main branch. After said changes, the
developer merges this branch into the main one. This branching strategy
consist of these branches:

-   Main.

-   Development.

-   Feature (to develop new features that branches off the develop
    > branch).

-   Release (to help a new production release; usually branched from the
    > develop branch and must be merged both into the develop and main
    > branches).

-   Hotfix. This one also helps to prepare for a release, but -unlike
    > the release one- the hotfix branch will emerge if there's a bug
    > that needs to be solved. It enables developers to work on a
    > different branch while said bug is being fixed.

The *main* and the *develop* branches are considered to be the main ones
to work on, while the rest are supportive branches that are meant to
help developers to, well, develop, and are usually short-lived.

###  **Rebase**

In git, this is a command that integrates the changes from one branch to
another, and works as an alternative for the "merge" command. Most
visibly, this command differs from the other by rewriting the commit
history in order to produce a 'linear' succession of commits.

To do this we code *git rebase*.

###  **Squash**

With this command, we can combine multiple commits into one. We can do
this at any point in time but it's most often used when we want to
finally merge a branch. It's important to note that there's no *git
squash* to do this, it's an option when using other commands like rebase
or merge.

Teams often use 'squashing' when they have way too many commits and
prefer to use only one, however, in teams with junior developers, it's
not that common so as they won't have the commit history to check on.

### **Rebase vs merge**

  Rebase                                                                                             Merge
  -------------------------------------------------------------------------------------------------- -----------------------------------------------------------------------------------------------
  Allows developers to integrate changes from one branch to another.                                 This command allows developers to merge branches.
  Logs are linear in git rebase as the commits are rebased.[^1]                                      With this one, the logs will be showing the complete history of the merging of commits.
  All the commits will be rebased and the same number of commits will be added to the main branch.   All the commits on the feature branch will be combined as a single commit in the main branch.
  This **should** be used when the target branch is a private branch.                                Merge is used when the target branch is a shared branch.

# ![](vertopal_02f27a16d689469f891c7e1f4ebd6d47/media/image3.png){width="3.71875in" height="1.8333333333333333in"}

# 

# 

# 

# 

# **JavaScript**

It's the third part of the holy trinity of programming along with HTML
and CSS. JavaScript is a programming language or a commands' sequence
that allows us to implement complex functions in a web page. This
language is oriented to objects.

Having previous knowledge in HTML and CSS is a recommendation to take
care of.

### [Concepts to keep in mind]{.ul}

-   Object oriented programming (OOP): is a programming style that
    > relies on the concept of classes and objects. It is used to
    > structure a software program into simple, reusable pieces of code
    > blueprint (called classes), which are used to create individual
    > instances of objects.
    > ![](vertopal_02f27a16d689469f891c7e1f4ebd6d47/media/image4.png){width="4.109375546806649in"
    > height="3.9411548556430445in"}

-   Class: it's an abstract blueprint used to create more specific,
    > concrete objects. Classes often represent wide categories like
    > "car" or "dog" that share attributes. These classes define what
    > attributes an instance of this type will have, like *color*, but
    > not the value of those attributes for a specific object. Classes
    > can also contain functions, called *methods* that are available
    > only to objects of that type. These functions are defined within
    > the class, and perform some action helpful to that specific type
    > of object.

    -   Class templates: these are used as a blueprint to create
        > individual objects. These represent specific examples of the
        > abstract class, like *myCar* or *goldenRetriever*. Each object
        > can have unique values to the properties defined in the class.

```{=html}
<!-- -->
```
-   Variable: it is a value that can change, depending on conditions or
    > on information passed to the program. Typically, a program
    > consists of instructions that tell the computer what to do and the
    > data that the program uses when it's running. Echa data type
    > prescribes and limits the form of the data. In OOP, each object
    > contains the data variables of the class it is an instance of. The
    > object's methods are designed to handle the actual values that are
    > supplied to the object when said object is being used.

> JavaScript variables can be: numbers, strings, objects, arrays and
> functions. For example:

![](vertopal_02f27a16d689469f891c7e1f4ebd6d47/media/image5.png){width="7.753871391076116in"
height="2.9276071741032372in"}

There are four ways to declare a JavaScript variable:

-   Using *var*

-   Using *let*

-   Using *const*

-   Using nothing :)

[When to use *var*]{.ul}

Always declare JS variables using one of the options above. The *var*
keyword is used in all JS code from 1995 to 2015. The *let* and *const*
keywords were added to JavaScript in 2015, so if we want our code to run
in older browsers, we must use *var*.

[When to use *const* and *let*]{.ul}

If we want to generalize a rule, we must declare the variables with
*const*. If the value of the variable can change, we use *let*.

![](vertopal_02f27a16d689469f891c7e1f4ebd6d47/media/image10.png){width="7.193349737532809in"
height="2.766673228346457in"}

# **HTML**

"HTML" stands for Hyper Text Markup Language. It's one of the three main
used programming languages along with CSS and JavaScript. This one
describes and delimits the skeleton of the web page.

To use this type of language, we need a text editor, like "Visual Studio
Code", to give an example. We also need a web browser. The purpose of a
web browser (like chrome, for example) is to read HTML documents and
display them correctly.

A browser does not display the HTML tags, but uses them to determine how
to display the document.

HTML consists of a series of elements that tell the browser how to
display the content. These elements label pieces of content such as
"this is the heading", "this is a paragraph", "this is a link", etc.

An element is defined by a start tag, some content and an end or closing
tag: \<tagname\> content goes here... \</tagname\>. It is everything
from the start tag to the closing tag. It's important to note that not
all elements need a closing tag, like de \<br\> tag.

### **Elements**

There are several types of elements, but the most basic and common used
ones are:

-   \<!DOCTYPE html\>: is a declaration that establishes this document
    > as a HTML5 document.

-   \<html\>: is the root element of an HTML page.

-   \<head\>: these elements contains meta information[^2] about the
    > HTML page.

-   \<title\>: this element specifies a tite for the page, which is
    > shown in the browser's title bar ir in the page's tab.

-   \<body\>: defines the main content of the page (like the body of a
    > letter), and is a container for all the visible contents such as
    > paragraphs, images, hyperlinks, headings, etc.

-   \<h1\>: stands for heading and defines, of course, a heading. There
    > are also other sizes of heading, \<h2\>, \<h3\>, \<h4\>, etc. each
    > one will be smaller as the number increases. We can use these to
    > create titles, subtitles, and so on.

-   \<p\>: this element describes a paragraph.

-   \<strong\>: makes the text bold.

-   \<em\>: stands for "emphasize" and changes the text's font into
    > cursive.

-   \<small\>: makes the text smaller, really subtle.

-   \<ul\>: stands for "unordered list" and closes vertically just like
    > the html, head and body tags. Between these tags we code \<li\>
    > tags.

-   \<li\>: these provide a list made with ballpoints.

-   \<ol\>: stands for "ordered list" and creates a list organized by
    > numbers starting on 1.

-   \<img\>: is used to add an image. By itself it does absolutely
    > nothing. *Also does not need a closing tag.* To tell the browser
    > what image to show, we use an attribute.

An attribute is something inside the tags that gives more information to
the browser about that tag. For images we use the "src" (source)
attribute like this:

> \<img src= ".png"\>

The .png file has been previously dragged inside of the working sheet;
we just create a path that connects them by using that command. We can
also cluster images inside a folder; in that case instead it would be
coded as:

\<img src= "img/.png"\>

The "alt" attribute is a text representation of the image. It's used to
describe the image for screen readers. Does not have a visual effect, is
for accessibility.

We do not *need* to remember all of these and other commands to be a
good developer, but we *must know* how to use them. We must understand
the bases to create a good path of development.

### **Inputs and forms**

An \<input\> is an element that allows us to create interactive controls
for forms based on the web to collect users information.

An HTML form is used to collect users\' input. The users' input is often
sent to a server for processing.

To create a form for users' input, we use the \<form\> element and it
does have a closing tag. It's a container for different types of input
elements, such as text fields, checkboxes, submit buttons, etc.

The \<input\> element is the most frequently used for forms. This type
of element can be used in many ways, depending on the *type* attribute.
For example:

-   \<input type= "text"\>: displays a single-line text input field.

-   \<input type= "radio"\>: displays a radio button for selecting one
    > of many choices.

-   \<input type= "submit"\>: this one displays a submit button for
    > submitting the form, of course.

-   \<input type= "button"\>: displays a simple clickable button :).

### **HTML vs XHTML**

XHTML stands for "Extensible Hypertext Markup Language\'\' and is
considered as a part of the XML markup language. It can also be
considered as a combination between HTML and XML.

XML is a software and hardware -independent tool for storing and
transporting data. It stands for "eXtensible Markup Language" and was
designed to be self-descriptive. It doesn't do quite anything, it's just
information wrapped in tags.

Someone must write a piece of software to send, receive, store or
display it.

HTML and XHTML were designed with different goals. While HTML5 was
created to solve some of the existing cross-browser compatibility
problems, XHTML was thought of as a more rigorous version of HTML.

Main differences:

-   HTML accepts that not all the elements present a closing tag,
    > whereas XHTML expects that all elements with no exception include
    > a closing tag.

-   XHTML requires that all attribute values, like the font size, are
    > quoted, even the numeric ones. Which does not happen with HTML.

-   For a document to be valid with XHTML, attributes can not be
    > minimized.

### **Data attributes**

They allow us to store additional information about an HTML element
without having to look for other more complex ways to do so and it;s
used as *data-\*,* being "\*" the kind of data we want to store. For
example:

\<li data-animal-type="bird"\>Owl\</li\>

This attribute allows us to lock up custom data on all HTML elements.

It consists of two parts:

-   The attribute name should not have any uppercase letters and must be
    > at least one character long after the "data-"

-   The attribute value can be any string.

### 

# **Bibliography** 

For agile methodologies:

> [[https://scrumguides.org/scrum-guide.html]{.ul}](https://scrumguides.org/scrum-guide.html)
>
> [[https://www.atlassian.com/es/agile/scrum/sprint-planning]{.ul}](https://www.atlassian.com/es/agile/scrum/sprint-planning)
>
> [[https://www.atlassian.com/es/agile/kanban]{.ul}](https://www.atlassian.com/es/agile/kanban)
>
> [[http://www.extremeprogramming.org/]{.ul}](http://www.extremeprogramming.org/)
>
> For Git:
>
> [[https://git-scm.com/]{.ul}](https://git-scm.com/)
>
> [[https://git-scm.com/about]{.ul}](https://git-scm.com/about)
>
> [[https://www.freecodecamp.org/news/10-important-git-commands-that-every-developer-should-know/]{.ul}](https://www.freecodecamp.org/news/10-important-git-commands-that-every-developer-should-know/)
>
> [[https://www.atlassian.com/es/git/tutorials/saving-changes/git-stash]{.ul}](https://www.atlassian.com/es/git/tutorials/saving-changes/git-stash)
>
> [[https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks]{.ul}](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)
>
> [[https://www.flagship.io/git-branching-strategies/]{.ul}](https://www.flagship.io/git-branching-strategies/)
>
> [[https://www.freecodecamp.org/espanol/news/la-guia-definitiva-para-git-merge-y-git-rebase/]{.ul}](https://www.freecodecamp.org/espanol/news/la-guia-definitiva-para-git-merge-y-git-rebase/)
>
> [[https://www.git-tower.com/learn/git/faq/git-squash]{.ul}](https://www.git-tower.com/learn/git/faq/git-squash)
>
> [[https://www.edureka.co/blog/git-rebase-vs-merge/\#:\~:text=Git%20Merge%20Vs%20Git%20Rebase%3A&text=Git%20merge%20is%20a%20command,of%20the%20merging%20of%20commits]{.ul}](https://www.edureka.co/blog/git-rebase-vs-merge/#:~:text=Git%20Merge%20Vs%20Git%20Rebase%3A&text=Git%20merge%20is%20a%20command,of%20the%20merging%20of%20commits).
>
> For JavaScript:
>
> [[https://developer.mozilla.org/es/docs/Learn/JavaScript/First_steps/What_is_JavaScript]{.ul}](https://developer.mozilla.org/es/docs/Learn/JavaScript/First_steps/What_is_JavaScript)
>
> [[https://www.w3schools.com/whatis/whatis_js.asp]{.ul}](https://www.w3schools.com/whatis/whatis_js.asp)
>
> [[https://www.freecodecamp.org/news/what-exactly-is-a-programming-paradigm/\#:\~:text=The%20term%20programming%20paradigm%20refers,that%20strategy%20is%20a%20paradigm]{.ul}](https://www.freecodecamp.org/news/what-exactly-is-a-programming-paradigm/#:~:text=The%20term%20programming%20paradigm%20refers,that%20strategy%20is%20a%20paradigm).
>
> [[https://www.educative.io/blog/object-oriented-programming]{.ul}](https://www.educative.io/blog/object-oriented-programming)
>
> [[https://www.techtarget.com/whatis/definition/variable\#:\~:text=In%20programming%2C%20a%20variable%20is,uses%20when%20it%20is%20running]{.ul}](https://www.techtarget.com/whatis/definition/variable#:~:text=In%20programming%2C%20a%20variable%20is,uses%20when%20it%20is%20running).
>
> [[https://www.w3schools.com/whatis/whatis_js.asp]{.ul}](https://www.w3schools.com/whatis/whatis_js.asp)
>
> [[https://www.w3schools.com/js/js_variables.asp]{.ul}](https://www.w3schools.com/js/js_variables.asp)
>
> For HTML:
>
> [[https://www.w3schools.com/html/html_intro.asp]{.ul}](https://www.w3schools.com/html/html_intro.asp)
>
> [[https://www.youtube.com/watch?v=hu-q2zYwEYs&list=PL4cUxeGkcC9ivBf_eKCPIAYXWzLlPAm6G&index=1&t=1046s]{.ul}](https://www.youtube.com/watch?v=hu-q2zYwEYs&list=PL4cUxeGkcC9ivBf_eKCPIAYXWzLlPAm6G&index=1&t=1046s)
>
> [[https://www.w3schools.com/html/html_forms.asp]{.ul}](https://www.w3schools.com/html/html_forms.asp)
>
> [[https://scandiweb.com/blog/html-vs-html5-vs-xhtml-the-difference-in-a-nutshell/]{.ul}](https://scandiweb.com/blog/html-vs-html5-vs-xhtml-the-difference-in-a-nutshell/)
>
> [[https://www.w3schools.com/xml/xml_whatis.asp]{.ul}](https://www.w3schools.com/xml/xml_whatis.asp)
>
> [[https://www.geeksforgeeks.org/difference-between-xhtml-and-html5/]{.ul}](https://www.geeksforgeeks.org/difference-between-xhtml-and-html5/)
>
> [[https://developer.mozilla.org/es/docs/Learn/HTML/Howto/Use_data_attributes]{.ul}](https://developer.mozilla.org/es/docs/Learn/HTML/Howto/Use_data_attributes)
>
> [[https://www.w3schools.com/tags/att_data-.asp]{.ul}](https://www.w3schools.com/tags/att_data-.asp)

[^1]: A log is an automatically produced and time-stamped documentation
    of events relevant to a particular system.. Virtually, all software
    applications and systems produce log files.

[^2]: Description of the information of an object.
